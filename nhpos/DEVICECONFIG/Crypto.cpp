#include "StdAfx.h"
#include "Crypto.h"

CCrypto::CCrypto(void)
{
	hCryptProv = 0; 
	hKey = 0; 
	hXchgKey = 0; 
	hHash = 0; 

	pbKeyBlob = 0; 
	dwKeyBlobLen = 0;
}

CCrypto::~CCrypto(void)
{
}


#include <tchar.h>
#include <string.h>

#if !defined(MS_STRONG_PROV)
// Code copied from latest Windows SDK header files to allow us
// to use the MS_STRONG_PROV Cryptographic Services Provider.
#define MS_STRONG_PROV_A        "Microsoft Strong Cryptographic Provider"
#define MS_STRONG_PROV_W        L"Microsoft Strong Cryptographic Provider"
#ifdef UNICODE
#define MS_STRONG_PROV          MS_STRONG_PROV_W
#else
#define MS_STRONG_PROV          MS_STRONG_PROV_A
#endif

#endif

/************************************************************************

Cryptographic Provider Names
The following cryptographic service provider (CSP) names
are defined: These constants are used with the
CryptAcquireContext and CryptSetProvider functions.

Defined name					Value 
MS_DEF_PROV					"Microsoft Base Cryptographic Provider v1.0" 
MS_ENHANCED_PROV			"Microsoft Enhanced Cryptographic Provider " 
MS_STRONG_PROV				"Microsoft Strong Cryptographic Provider" 
MS_DEF_RSA_SIG_PROV			"Microsoft RSA Signature Cryptographic Provider" 
MS_DEF_RSA_SCHANNEL_PROV	"Microsoft RSA SChannel Cryptographic Provider" 
MS_DEF_DSS_PROV				"Microsoft Base DSS Cryptographic Provider" 
MS_DEF_DSS_DH_PROV			"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider" 
MS_ENH_DSS_DH_PROV			"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider" 
MS_DEF_DH_SCHANNEL_PROV		"Microsoft DH SChannel Cryptographic Provider" 
MS_SCARD_PROV				"Microsoft Base Smart Card Cryptographic Provider" 


Hash algorithm names
The following constants are used with the 
CryptCreateHash function.

Defined name			Value				Specified by Provider Types
CALG_MD5			MD5 algorithm		PRON_RSA_FULL, PROV_RSA_SIG, PROV_DSS, PROV_DSS_DH, and PROV_MS_EXCHANGE
CALG_SHA			SHA-1 algorithm
CALG_3DES			Triple DES algorithm


GetLastError () return values CryptAcquireContext(), CryptEncrypt().

The error codes prefaced by NTE are generated by the particular CSP being used.
Some possible error codes follow. 

ERROR_NOT_ENOUGH_MEMORY ( 8L ) 
  The operating system ran out of memory during the operation. 

ERROR_INVALID_PARAMETER ( 87L ) 
  One of the parameters contains an invalid value. This is most often an invalid pointer. 

ERROR_BUSY ( 107L ) 
  Some CSPs set this error if the CRYPT_DELETEKEYSET flag value is set and another
  thread or process is using this key container. 

ERROR_MORE_DATA (234L)
  The buffer specified is not large enough to hold the data (function CryptEncrypt).

NTE_BAD_SIGNATURE( 0x80090006L ) 
  The provider DLL signature could not be verified. Either the DLL or the digital
  signature has been tampered with. 

NTE_BAD_ALGID (0x80090008L)
  The Algid parameter specifies an algorithm that this CSP does not support.

NTE_BAD_FLAGS ( 0x80090009L ) 
  The dwFlags parameter has an invalid value.

NTE_NO_MEMORY( 0x8009000EL ) 
  The CSP ran out of memory during the operation. 

NTE_EXISTS( 0x8009000FL ) 
  The dwFlags parameter is CRYPT_NEWKEYSET, but the key container already exists. 

NTE_BAD_PROV_TYPE( 0x80090014L ) 
  The value of the dwProvType parameter is out of range. All provider types must be from 1 to 999, inclusive. 

NTE_BAD_KEYSET( 0x80090016L ) 
  The key container could not be opened. A common cause of this error is that the key container
  does not exist. To create a key container, call CryptAcquireContext using the CRYPT_NEWKEYSET flag.
  This error code can also indicate that access to an existing key container is denied. Access rights
  to the container can be granted by the key set creator using CryptSetProvParam. 

NTE_BAD_KEYSET_PARAM( 0x8009001FL ) 
  The pszContainer or pszProvider parameter is set to an invalid value. 

NTE_PROV_DLL_NOT_FOUND( 0x80090016L ) 
  The provider DLL file does not exist or is not on the current path. 

NTE_PROV_TYPE_NOT_DEF( 0x80090017L ) 
  No entry exists for the provider type specified by dwProvType. 

NTE_PROV_TYPE_ENTRY_BAD( 0x80090018L ) 
  The provider type specified by dwProvType is corrupt. This error can relate to either the
  user default CSP list or the computer default CSP list. 

NTE_KEYSET_NOT_DEF( 0x80090019L ) 
  The key container specified by pszContainer does not exist or the requested provider does not exist. 

NTE_KEYSET_ENTRY_BAD( 0x8009001AL ) 
  The pszContainer key container was found but is corrupt. 

NTE_PROV_TYPE_NO_MATCH( 0x8009001BL ) 
  The provider type specified by dwProvType does not match the provider type found. Note that this error
  can only occur when pszProvider specifies an actual CSP name. 

NTE_SIGNATURE_FILE_BAD( 0x8009001CL ) 
  An error occurred while loading the DLL file image, prior to verifying its signature. 

NTE_PROVIDER_DLL_FAIL( 0x8009001DL ) 
  The provider DLL file could not be loaded or failed to initialize. 

**************************************************************************/

#define MY_ENCODING_TYPE      (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)
  // indicate 128 bit session key
#define KEYLENGTH             0x00800000



//--------------------------------------------------------------------
//   Declare and initialize local variables.

int  CCrypto::RflConstructEncryptByteStringClass (CHAR *szPassword)
{
	// Get handle to the default provider. 
	if(! CryptAcquireContext(&hCryptProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
		m_dwLastError = GetLastError();
		if (m_dwLastError == NTE_EXISTS) {
			if(! CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)) {
				return -1;
			}
		}
		else {
			return -1;
		}
	}

	//--------------------------------------------------------------------
	//   Create the session key.
	if(szPassword || szPassword [0] != 0) { 
		RflRehashEncryptDecrypt (szPassword);
	} 
	//--------------------------------------------------------------------
	//  The session key is now ready. If it is not a key derived from a 
	//  password, the session key encrypted with the encrypter's private 
	//  key has been written to the destination file.

	return 1;
}


VOID CCrypto::RflDestructEncryptByteStringClass (VOID)
{
	//--------------------------------------------------------------------
	// Destroy session key. 
	if(hKey) 
		CryptDestroyKey(hKey); 

	//--------------------------------------------------------------------
	// Release key exchange key handle. 
	if(hXchgKey) 
		CryptDestroyKey(hXchgKey); 
 
	//--------------------------------------------------------------------
	// Destroy hash object. 
	if(hHash) 
		CryptDestroyHash(hHash); 
 
	//--------------------------------------------------------------------
	// Release provider handle. 
	if(hCryptProv) 
		CryptReleaseContext(hCryptProv, 0);

	hKey = hXchgKey = hHash = hCryptProv = 0;
}


int  CCrypto::RflRehashEncryptDecrypt (CHAR *szPassword)
{
	//--------------------------------------------------------------------
	// Destroy session key as we are going to create a new one.
	if(hKey) {
		CryptDestroyKey(hKey);
		hKey = 0;
	}

	//--------------------------------------------------------------------
	// Destroy hash object as we are going to create a new one.
	if(hHash) {
		CryptDestroyHash(hHash);
		hHash = 0;
	}

	// Create a hash object. We are using CALG_MD5 (MD5) for our hashing algorithm.
	if(! CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash)) {
		m_dwLastError = GetLastError();
		RflDestructEncryptByteStringClass();
		return -1;
	}

	//--------------------------------------------------------------------
	// Hash the password. 
	if(! CryptHashData(hHash, (BYTE *)szPassword, strlen(szPassword), 0)) {
		m_dwLastError = GetLastError();
		RflDestructEncryptByteStringClass();
		return -1;
	}

	//--------------------------------------------------------------------
	// Derive a session key from the hash object. 
	if(! CryptDeriveKey(hCryptProv, CALG_3DES, hHash, (0), &hKey)) {
		m_dwLastError = GetLastError();

		if(! CryptDeriveKey(hCryptProv, CALG_DES, hHash, (0), &hKey)) {
			m_dwLastError = GetLastError();

			if(! CryptDeriveKey(hCryptProv, CALG_RC4, hHash, (0), &hKey)) {
				m_dwLastError = GetLastError();
				RflDestructEncryptByteStringClass();
				return -1;
			}
		}
	}

	//--------------------------------------------------------------------
	// Destroy the no longer needed hash object. 
	CryptDestroyHash(hHash); 
	hHash = 0;

	memcpy (ucPasswordSaveAndCheck, szPassword, sizeof(ucPasswordSaveAndCheck));
	return 0;
} 


UCHAR * CCrypto::RflEncryptByteString (UCHAR *bsString, int nByteCount, int nBuffLen)
{
	DWORD  dwCount = nByteCount;

	// ensure that we have an encryption key and that the string is not empty
	if (hKey && bsString && (bsString[0] | bsString[1]) != 0) {
		// Encrypt data. 
		if(!CryptEncrypt(hKey, 0, TRUE, 0, bsString, &dwCount, nBuffLen))
		{
			m_dwLastError = GetLastError();

			bsString[nBuffLen - 1] = 0;
			bsString = NULL;
		}
		else {
			bsString[nBuffLen - 1] = (UCHAR) dwCount;
		}
	}
	else {
		bsString[nBuffLen - 1] = 0;
		bsString = NULL;
	}
	return bsString;
}


UCHAR * CCrypto::RflDecryptByteString (UCHAR *bsString, int nByteCount, int nBuffLen)
{
	DWORD  dwCount = (DWORD) nByteCount;

	// Lets make sure that we do not try to decrypt an already decrypted string
	if (hKey && bsString && (bsString[0] | bsString[1]) != 0 && dwCount && dwCount < nBuffLen) {
		if(!CryptDecrypt(hKey, 0,TRUE, 0, bsString, &dwCount))
		{
			m_dwLastError = GetLastError();

			bsString = NULL;
		}
		else {
			nByteCount = dwCount;
			bsString[dwCount] = 0;
		}
	}
	else {
		bsString = NULL;
	}

	return bsString;
}


UCHAR * CCrypto::RflEncryptSerialNoString (UCHAR *bsSerialNumber, UCHAR bsString[48])
{
	int    i;
	int    iLen = strlen ((char *)bsSerialNumber);

	for (i = 1; i < 47; i++) {
		bsString[i] = (rand () % 254) + 1;
	}

	bsString[0] = (iLen & 0xff);
	for (i = 0; i < iLen; i++) {
		bsString[(i * 2) + 1] = bsSerialNumber[i];
	}

	for (i = 0; i < 47; i++) {
		bsString[i] ^= ((i << 2) | 0x10);
	}

	int cheksum = 0;
	for (i = 0, cheksum = 0; i < 47; i++) {
		cheksum += bsString[i];
	}
	bsString[47] = (cheksum & 0x00ff);

	return bsString;
}

UCHAR * CCrypto::RflDecryptSerialNoString (UCHAR *bsSerialNumber, UCHAR bsString[48])
{
	int i;

	// init to an empty string and begin processing
	bsSerialNumber[0] = 0;

	int cheksum = 0;
	for (i = 0, cheksum = 0; i < 47; i++) {
		cheksum += bsString[i];
	}
	if (bsString[47] != (cheksum & 0x00ff)) return bsSerialNumber;

	for (i = 0; i < 47; i++) {
		bsString[i] ^= ((i << 2) | 0x10);
	}

	int iLen = bsString[0];

	for (i = 0; i < iLen; i++) {
		bsSerialNumber[i] = bsString[(i * 2) + 1];
	}
	bsSerialNumber[i] = 0;

	return bsSerialNumber;
}

