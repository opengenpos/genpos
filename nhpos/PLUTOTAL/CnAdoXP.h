// CnAdoXP.h: interface for the CnAdoXP class.
//
//////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//make sure the path to msado15.dll is listed in
//visual C++ 6.0 options under the Tools Menu
//directories tab, Show Directories for: Executable files

// WARNING: If compiled with Visual Studio 2005 under Windows 7 SP1 there will be a problem with
//          Windows XP.  In Windows 7 SP1 there was a change made to msado15.dll introducing UUIDs
//          that were different for some interfaces to ADO.  The result is that compiling in Windows 7
//          will result in a build that will not be able to make changes to the PLU totals database.
//
//          See Microsoft KB article 2517589 http://support.microsoft.com/kb/2517589,
//              An ADO application does not run on down-level operating systems after you
//              recompile it on a computer that is running Windows 7 SP 1 or Windows Server
//              2008 R2 SP 1 or that has KB983246 installed
//
// WARNING: if compiled with Visual Studio 2013 under Windows 7 SP1 there will be a problem with
//          Windows XP. Rather than the work around for Visual Studio 2005 using msado28.dll
//          you instead need to use msado60.tlb which appears to have the class ids corrected.

#include "ecr.h"

#if defined(GENPOS_REL_020300)
// for Windows 7 SP1 development environment with Visual Studio 2013 to target Windows XP and Windows 7 use the following
// see "An ADO-based application that is compiled in Windows 7 SP1 or in Windows Server 2008 R2 SP1 does not run in earlier versions of Windows" at URL:
//    https://support.microsoft.com/en-us/kb/2640696
#import <C:\Program Files (x86)\Common Files\System\ado\msado60.tlb> no_namespace rename("EOF", "adoEOF")
#else
#if 1
// for Windows XP development environment use the following
#import <C:\Program Files\Common Files\System\ado\msado15.dll> no_namespace rename("EOF", "adoEOF")
#else
// for Windows 7 SP1 development environment with Visual Studio 2005 to target Windows XP and Windows 7 use the following
#import <C:\Program Files (x86)\Common Files\System\ado\msado28.tlb> no_namespace rename("EOF", "adoEOF")
#endif
#endif

#include "pif.h"
#include "log.h"

//Replace CnAdoCERec with CnAdoXPRec when
//building for Windows 2000/XP
//#define CnAdoCERec CnAdoXPRec
//#define m_pRecordSet recordsetPtr

typedef	class COleVariant	CnVariant;

class CnAdoXPRec
{
private:
	static int			s_nObjCnt;
	BOOL				m_bOpened;

protected:
	_RecordsetPtr		m_pRecordSet;	// recordset object
	_ConnectionPtr		m_pConnection;

public:
	HRESULT	 m_hr;						// ADO status (result)
	CString  m_errorMessage;            // error message generated by exception handling.

protected:
	virtual	BOOL		CreateObject();
	virtual	VOID		DestroyObject();

public:
						CnAdoXPRec();		// standard constructor
	virtual 			~CnAdoXPRec();		// destructor
	static	CnAdoXPRec * Create() {return (new CnAdoXPRec());};

	BOOL	IsOpened(void){ return m_bOpened; };

	virtual	HRESULT	AddNew(CnVariant FieldList,CnVariant Values){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->AddNew(FieldList,Values);
		}
		catch(_com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR AddNew %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_ADDNEW);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
		}
		return m_hr;
	}

	virtual HRESULT Close(void){ 
		m_errorMessage.Empty();
		m_bOpened = FALSE;
		try {
			m_hr = m_pRecordSet->Close();
		}
		catch( _com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR Close %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (m_pConnection) {
			if (m_pConnection->State == adStateOpen)
			{
				m_pConnection->Close();
			}
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			if (m_hr != 0x800A0E78) {
				// print the PIFLOG only if not Operation not allowed.
				// "ERROR Close Unknown error 0x800A0E78  Operation is not allowed when the object is closed."
				PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_CLOSE);
				PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
				{
					char xBuff[256];
					sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
					NHPOS_NONASSERT_TEXT(xBuff);
				}
			}
		}
		return m_hr;
	}

	virtual	HRESULT	Delete(long AffectRecords = 1){ 
		m_errorMessage.Empty();
		try {
			AffectEnum enAffectRecords = (enum AffectEnum)AffectRecords;
			m_hr = m_pRecordSet->Delete(enAffectRecords);
		}
		catch(_com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR Delete %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_DELETE);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
		}
		return m_hr;
	}

	virtual	HRESULT	GetRows(long Rows,VARIANT Start,VARIANT Fields,VARIANT __RPC_FAR *pvar) {
		m_errorMessage.Empty();
		try
		{
			m_hr = m_pRecordSet->raw_GetRows(Rows,vtMissing,Fields,pvar);
		}
		catch(_com_error &e)
		{
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR GetRows %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_GETROWS);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
		}
		return m_hr;
	}

	virtual	 HRESULT	GetRow(CnVariant Fields,CnVariant __RPC_FAR *pvar) {
		// Error Type: ADODB.Recordset (0x800A0CC1)
		//   Item cannot be found in the collection corresponding to the requested name
		//   or ordinal.
		//
		// Error Type: ADODB.Field (0x800A0BCD)
		//   Either BOF or EOF is True, or the current record has been deleted. Requested
		//   operation requires a current record

		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->raw_GetRows(1L,vtMissing,Fields,pvar);
		}
		catch(_com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR GetRow %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_GETROW);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
		}
		return m_hr;
	}

	virtual	HRESULT	Move(long NumRecords, CnVariant Start) {
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->Move(NumRecords,Start);
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT	MoveFirst(void){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->MoveFirst();
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT	MoveLast(void){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->MoveLast();
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT	MoveNext(void){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->MoveNext();
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT	MovePrevious(void){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->MovePrevious();
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT Open(CnVariant Source,_bstr_t ActiveConnection)
	{
		m_errorMessage.Empty();
		try {
			if (m_pConnection->State != adStateOpen)
			{
				m_pConnection->ConnectionString = ActiveConnection;
				m_pConnection->Open("", "", "", -1);
			}
			m_hr = m_pRecordSet->Open((VARIANT)Source, _variant_t((IDispatch *)m_pConnection),adOpenKeyset,adLockOptimistic,0);
		}
		catch( _com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR Open %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}           
		if (!FAILED(m_hr)) {
			m_bOpened = TRUE;
		}
		else {
			TRACE3("%S(%d): %s", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_OPEN);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char  xBuffer[512];

				sprintf(xBuffer, "LOG_ERROR_TOTALUM_OPEN: %S", (LPCTSTR)m_errorMessage);
				NHPOS_ASSERT_TEXT(0, xBuffer);
			}
		}
		return	m_hr;
	}

	virtual	HRESULT OpenRec(CnVariant Source,_bstr_t ActiveConnection,
			CursorTypeEnum CursorType = adOpenKeyset,
			LockTypeEnum LockType = adLockOptimistic,
			long Options = adCmdUnknown)
	{
		m_errorMessage.Empty();
		try {
			if (m_pConnection->State != adStateOpen)
			{
				m_pConnection->ConnectionString = ActiveConnection;
				m_pConnection->Open("", "", "", -1);
			}
			m_hr = m_pRecordSet->Open((VARIANT)Source, _variant_t((IDispatch *)m_pConnection),CursorType,LockType,Options);
		}
		catch( _com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR OpenRec %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
#if 0
			{
				char xBuff[256];
				sprintf(xBuff, "%S", e.ErrorMessage());
				NHPOS_NONASSERT_TEXT(xBuff);
				int iLen = wcslen(description);
				sprintf(xBuff, "%S", description);
				NHPOS_NONASSERT_TEXT(xBuff);
				if (iLen > 110) {
					iLen -= 110;
					sprintf(xBuff, "%S", description + iLen);
					NHPOS_NONASSERT_TEXT(xBuff);
				}
			}
#endif
		}
		if (!FAILED(m_hr)) {
			m_bOpened = TRUE;
		}
		else {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
#if 0
			// removed Jul-30-2013 to reduce number of logs generated during End of Day
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_OPENREC);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
#endif
		}
		return	m_hr;
	}

	virtual	 HRESULT STDMETHODCALLTYPE Update(CnVariant Fields, CnVariant Values) {
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->Update((VARIANT)Fields,(VARIANT)Values);
		}
		catch(_com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR Update %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_UPDATE);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
		}
		return m_hr;
	}

	virtual	HRESULT	STDMETHODCALLTYPE get_BOF(BOOL *pbVal){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->get_BOF((VARIANT_BOOL __RPC_FAR *)pbVal);
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT	STDMETHODCALLTYPE get_EOF(VARIANT_BOOL *pbVal){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->get_adoEOF((VARIANT_BOOL __RPC_FAR *)pbVal);
		}
		catch(_com_error &e) {
			m_hr = e.Error();
		}
		return m_hr;
	}

	virtual	HRESULT	get_RecordCount(long __RPC_FAR *pVal){
		m_errorMessage.Empty();
		try {
			m_hr = m_pRecordSet->get_RecordCount(pVal);
		}
		catch(_com_error &e) {
			_bstr_t bstrSource(e.Description());
			TCHAR *description;
			description = bstrSource;
			m_errorMessage.Format(_T("ERROR get_RecordCount %s  %s"), e.ErrorMessage(), description);
			m_hr = e.Error();
		}
		if (FAILED(m_hr)) {
			TRACE3("%S(%d): %s\n", __FILE__, __LINE__, m_errorMessage);
			PifLog(MODULE_PLU_TOTAL, LOG_ERROR_TOTALUM_GETRECCNT);
			PifLog(MODULE_ERROR_NO(MODULE_PLU_TOTAL), (USHORT)abs(m_hr));
			{
				char xBuff[256];
				sprintf (xBuff, "%S", (LPCTSTR)m_errorMessage);
				NHPOS_NONASSERT_TEXT(xBuff);
			}
		}
		return m_hr;
	}
};