/****************************************************************************\
||																			||
||		  *=*=*=*=*=*=*=*=*													||
||        *  NCR 2127 OMW *             NCR Corporation, E&M OISO			||
||     @  *=*=*=*=*=*=*=*=*  0             (C) Copyright, 1993				||
||    <|\/~               ~\/|>												||
||   _/^\_                 _/^\_											||
||																			||
\****************************************************************************/

/*==========================================================================*\
*	Title:
*	Category:
*	Program Name:
* ---------------------------------------------------------------------------
*	Compiler:		MS-C Ver. 6.00 A by Microsoft Corp.
*	Memory Model:
*
* ---------------------------------------------------------------------------
*	Abstract:
*      This file contains the queuing primitives used by the PIFNET subsystem
*      to implement a transaction monitor architecture.  These primitives
*      allow PIFNET to put I/O requests onto various queues scheduling the
*      I/O request within NetManager.
*
*      In addition, these primitives are used by other threads within the
*      PIFNET subsystem to schedule reads within the NetReceiver thread and
*      timer events generated by the SleepTimer thread.
*
*      Finally, NetReceiver and SleepTimer use these queue primitives to
*      send I/O and timer results to NetManager allowing NetManager to
*      integrate those I/O results into the transaction monitor data flow to
*      satisfy outstanding I/O requests and to perform aging and Time To Live
*      calculations on outstanding I/O requests.
*
*      The QueBuffer primitives such as QueGetBuffer () are used not only
*      by the SysQueue primitives in this file but also directly by the
*      network I/O transaction monitor in net_body.c.
*
*      The PIFNET subsystem appears to be the only user of these functions.
*
* ---------------------------------------------------------------------------
*	Update Histories:
* ---------------------------------------------------------------------------
*	Date     | Version  | Descriptions							| By
* ---------------------------------------------------------------------------
*			 |			|										|
\*==========================================================================*/

/*==========================================================================*\
:	PVCS ENTRY
:-------------------------------------------------------------------------
:	$Revision$
:	$Date$
:	$Author$
:	$Log$
\*==========================================================================*/

/*==========================================================================*\
;+																			+
;+					I N C L U D E    F I L E s								+
;+																			+
\*==========================================================================*/

#if defined(SARATOGA) 
# include	<windows.h>							/* Windows header			*/
# include   "pif.h"
#elif defined(SARATOGA_PC)
# include	<windows.h>							/* Windows header			*/
# include   "pif.h"
#elif defined (SERVER_NT)					/* WindowsNT model ?			*/
# include	<windows.h>							/* Windows header			*/
#endif

/* --- C-library header --- */

#include	<memory.h>						/* memxxx() C-library header	*/

/* --- our common headers --- */

#include	"piftypes.h"					/* type modifier header			*/
#include	"pifnet.h"						/* PifNet common header			*/
#define		NET_QUEUE
#define		NET_SYSTEM
#include	"netmodul.h"					/* our module header			*/

/*==========================================================================*\
;+																			+
;+					L O C A L     D E F I N I T I O N s						+
;+																			+
\*==========================================================================*/

/* --- queue list --- */
 typedef struct _QUELST {					/* extended queue list			*/
	USHORT		usQueNo;						/* queue ID					*/
	SEMOBJ		semAttach;						/* queue access semaphore	*/
	EVTOBJ		evtSignal;						/* queue event signal		*/
	QUEPTR		queList;						/* queue list ptr.			*/
 } QUELST, *PQUELST;

/*==========================================================================*\
;+																			+
;+			P R O T O T Y P E     D E C L A R A T I O N s					+
;+																			+
\*==========================================================================*/

/* --- queue signal handlings --- */

static	VOID	QueInitResource(PQUELST);		/* initialize a resource	*/
static	VOID	QueDeleteResource(PQUELST);		/* delete a resource		*/
static	VOID	QueAttachResource(PQUELST);		/* attach a resource		*/
static	VOID	QueFreeResource(PQUELST);		/* free a resource			*/

/*==========================================================================*\
;+																			+
;+					S T A T I C   V A R I A B L E s							+
;+																			+
\*==========================================================================*/

/* --- queue resources --- */

//static	SEMOBJ FAR semQueue;					/* queue list access sem.	*/
static  CRITICAL_SECTION csQueueCriticalSection;
static	QUELST  queArray[NO_OF_QUEUES];		/* queue list array			*/

/*==========================================================================*\
;+																			+
;+				C O N S T A N T    D E F I N I T I O N s					+
;+																			+
\*==========================================================================*/


/*==========================================================================*\
;+																			+
;+				Q U E U E     M A N A G E R									+
;+																			+
\*==========================================================================*/

/**
;========================================================================
;
;   function : Initialize queue manager
;
;   format : USHORT		SysInitializeQueue();
;
;   input  : nothing
;
;   output : USHORT		usRet;			- return status
;
;========================================================================
**/

USHORT	SysInitializeQueue(VOID)
{
	/* --- create a semaphore to control access to the
		SysQueue data structures as multiple threads will
		be accessing these queue primitives.
	--- */

//	SysSemCreate(&semQueue, FALSE);				/* create a semaphore		*/
	InitializeCriticalSection (&csQueueCriticalSection);

	/* --- initialize queue list --- */
	memset(queArray, '\0', sizeof(queArray));	/* initialize queue array	*/

	return (0);
}

/**
;========================================================================
;
;   function : Destory queue manager
;
;   format : USHORT		SysDestroyQueue();
;
;   input  : nothing
;
;   output : USHORT		usRet;			- return status
;
;========================================================================
**/

USHORT	SysDestroyQueue(VOID)
{
	/* --- destroy a semaphore --- */

//	SysSemClose(&semQueue);						/* close a semaphore		*/
	DeleteCriticalSection (&csQueueCriticalSection);

	/* --- initialize queue list
		We hope that by doing this, if someone attempts to use the queue list
		anyway, an error will be generated.
		Inspection of code indicates this function is never invoked.
	--- */
	memset(queArray, '\0', sizeof(queArray));	/* initialize queue array	*/

	return (0);
}

/**
;========================================================================
;
;   function : Create a queue
;
;   format : USHORT		SysCreateQueue(usQueNo);
;
;   input  : USHORT		usQueNo;		- queue ID
;
;   output : USHORT		usRet;			- return status
;
;========================================================================
**/

USHORT	SysCreateQueue(USHORT usQueNo)
{
	USHORT		usRet;
	int 		i;
	PQUELST		pQueues, pFound;

	/* --- is valid queue ID ? --- */
	if (! usQueNo) {							/* valid ID given ?			*/
		return (ERROR_SYS_INVALID_DATA);			/* invalid parameter	*/
	}

	/* --- claim to a queue semaphore --- */
//	SysSemRequest(&semQueue, WAIT_FOREVER);		/* claim to a semaphore		*/
	EnterCriticalSection (&csQueueCriticalSection);

	/* --- compute queue ptr. --- */
	usRet   = ERROR_SYS_NO_RESOURCE;			/* assume no free resource	*/
	pQueues = queArray;							/* top of queue list		*/
	pFound  = _NULL;							/* assume not found			*/

	/* --- look for vacant queue --- */
	for (i = 0; i < ARRAYS(queArray); i++) {	/* look for vacant cell		*/
		/* --- is duplicated ? --- */
		if (pQueues->usQueNo == usQueNo) {		/* inspect the queue ID		*/
			usRet = ERROR_SYS_DUP_RESOURCE;			/* cannot make same que	*/
			break;
		}
		else if ((! pQueues->usQueNo) && (! pFound)) {
			/* --- is this a vacant queue cell ? --- */
			pFound = pQueues;						/* get its address		*/
			usRet  = 0;								/* found it !			*/
			break;
		}
		/* --- how about next queue cell ? --- */
		pQueues++;								/* go to next queue			*/
	}

	/* --- found vacant cell with success ? --- */
	if ((! usRet) && pFound) {					/* found vacant cell ?		*/
		/* --- initialize the queue --- */
		QueInitialize(&(pFound->queList));		/* initialize it			*/
		QueInitResource(pFound);				/* initialize it			*/
		/* --- remember its ID --- */
		pFound->usQueNo  = usQueNo;				/* remember its queue ID	*/
	}

	/* --- free a semaphore --- */
//	SysSemClear(&semQueue);
	LeaveCriticalSection (&csQueueCriticalSection);

	return (usRet);
}

/**
;========================================================================
;
;   function : Read from a queue
;
;   format : USHORT		SysReadQueue(usQueNo, ppvRead, ulTimeOut);
;
;   input  : USHORT		usQueNo;		- queue ID
;			 PQUEBUF *	ppvRead;		- ptr. to receive a mail ptr.
;			 ULONG		ulTimeOut;		- time out value in msec
;
;   output : USHORT		usRet;			- return status
;
;========================================================================
**/

USHORT	SysReadQueue(USHORT usQueNo, PQUEBUF * ppvRead, ULONG ulTimeOut)
{
	USHORT		usRet;
	int		i;
	PQUELST		pQueues;
	PQUEBUF		pBuffer;

	/* --- is valid queue ID ? --- */
	if (! usQueNo) {							/* valid ID given ?			*/
		return (ERROR_SYS_INVALID_DATA);			/* invalid parameter	*/
	}

	/* --- claim to a queue semaphore --- */
//	SysSemRequest(&semQueue, WAIT_FOREVER);		/* claim to a semaphore		*/
	EnterCriticalSection (&csQueueCriticalSection);

	/* --- compute queue ptr. --- */
	usRet    = ERROR_SYS_NO_RESOURCE;			/* assume no resource		*/
	pQueues  = queArray;						/* top of queue list		*/
	*ppvRead = _NULL;							/* assume no message		*/
	pBuffer  = _NULL;							/* initialize queued message*/

	/* --- look for the queue --- */
	for (i = 0; i < ARRAYS(queArray); i++) {	/* look for the queue cell	*/
		/* --- found the queue ? --- */
		if (pQueues->usQueNo == usQueNo) {		/* inspect the queue ID		*/
			usRet = 0;								/* completed status		*/
			break;									/* break my job here	*/
		}
		/* --- how about next queue cell ? --- */
		pQueues++;								/* go to next queue			*/
	}
	LeaveCriticalSection (&csQueueCriticalSection);

	/* --- has been found ? --- */
	if (0 == usRet) {								/* has been found ?			*/
		/* --- claim to the access semaphore --- */
		QueAttachResource(pQueues);				/* attach a resource		*/

		/* --- try to get the message from the queue --- */
		if (pBuffer = QueGetBuffer(&(pQueues->queList))) {
			*ppvRead = pBuffer;
		}
		else if (ulTimeOut) {					/* wait for some seconds ?	*/
			/* --- else, no messages on queue ... --- */
			SysEventBlock(&(pQueues->evtSignal));	/* set event signal		*/
		}
		else {									/* immediate return ...		*/
			usRet = ERROR_SYS_QUE_EMPTY;			/* queue empty !		*/
		}
		/* --- free the semaphore --- */
		QueFreeResource(pQueues);				/* free a resource			*/
	}

	/* --- free a semaphore --- */
//	SysSemClear(&semQueue);

	/* --- completed ? --- */
	// Check to see if we either have an error or we have pulled a buffer off the
	// queue. In either case we will return.  Otherwise we will drop through and
	// wait for an event indicating that we have received a message.
	if (usRet || pBuffer) {						/* found or any errors ?	*/
		return (usRet);								/* break my job here	*/
	}

	/* --- wait for a message queued --- */
	/* --- assume time-out status --- */
	usRet = ERROR_SYS_TIMEOUT;					/* assume time out status	*/

	/* --- wait for a signal --- */
	if (SysEventWait(&(pQueues->evtSignal), ulTimeOut)) {
		/* --- claim to the access semaphore --- */
		QueAttachResource(pQueues);				/* attach a resource		*/

		/* --- get the message from the queue --- */
		*ppvRead = QueGetBuffer(&(pQueues->queList));
		usRet    = 0;							/* completed status			*/

		QueFreeResource(pQueues);				/* free a resource			*/
	}

	return (usRet);
}

/**
;========================================================================
;
;   function : Write to a queue
;
;   format : USHORT		SysWriteQueue(usQueNo, pSend);
;
;   input  : USHORT		usQueNo;		- queue ID
;			 PQUEBUF	pSend;			- ptr. to send mail
;
;   output : USHORT		usRet;			- return status
;
;========================================================================
**/
USHORT	SysWriteQueue(USHORT usQueNo, PQUEBUF pSend)
{
	USHORT		usRet;
	int		i;
	PQUELST		pQueues;

	/* --- is valid queue ID ? --- */
	if (! usQueNo) {							/* valid ID given ?			*/
		return (ERROR_SYS_INVALID_DATA);			/* invalid parameter	*/
	}

	/* --- claim to a queue semaphore --- */
//	SysSemRequest(&semQueue, WAIT_FOREVER);		/* claim to a semaphore		*/
	EnterCriticalSection (&csQueueCriticalSection);

	/* --- compute queue ptr. --- */
	usRet   = ERROR_SYS_NO_RESOURCE;			/* assume no resource		*/
	pQueues = queArray;							/* top of queue list		*/

	/* --- look for the queue --- */
	for (i = 0; i < ARRAYS(queArray); i++) {	/* look for the queue cell	*/
		/* --- found the queue ? --- */
		if (pQueues->usQueNo == usQueNo) {		/* inspect the queue ID		*/
			usRet = 0;								/* completed status		*/
			break;									/* break my job here	*/
		}
		/* --- how about next queue cell ? --- */
		pQueues++;								/* go to next queue			*/
	}
	LeaveCriticalSection (&csQueueCriticalSection);

	/* --- has been found ? --- */
	if (0 == usRet) {								/* has been found ?			*/
		/* --- claim to the access semaphore --- */
		QueAttachResource(pQueues);				/* attach a resource		*/

		/* --- list the message on the queue --- */
		QueListBuffer(&(pQueues->queList), pSend);

		/* --- free the semaphore --- */
		QueFreeResource(pQueues);				/* free a resource			*/

		/* --- issue a signal, to make sure --- */
		SysEventSignal(&(pQueues->evtSignal));
	}

	/* --- free a semaphore --- */
//	SysSemClear(&semQueue);

	return (usRet);
}

/**
;========================================================================
;
;   function : Close a queue
;
;   format : USHORT		SysCloseQueue(usQueNo);
;
;   input  : USHORT		usQueNo;		- queue ID
;
;   output : USHORT		usRet;			- return status
;
;========================================================================
**/

USHORT	SysCloseQueue(USHORT usQueNo)
{
	USHORT		usRet;
	int		i;
	PQUELST		pQueues;

	/* --- is valid queue ID ? --- */
	if (! usQueNo) {							/* valid ID given ?			*/
		return (ERROR_SYS_INVALID_DATA);			/* invalid parameter	*/
	}

	/* --- claim to a queue semaphore --- */
//	SysSemRequest(&semQueue, WAIT_FOREVER);		/* claim to a semaphore		*/
	EnterCriticalSection (&csQueueCriticalSection);

	/* --- compute queue ptr. --- */
	usRet   = ERROR_SYS_NO_RESOURCE;			/* assume no resource		*/
	pQueues = queArray;							/* top of queue list		*/

	/* --- look for the queue --- */
	for (i = 0; i < ARRAYS(queArray); i++) {	/* look for the queue cell	*/
		/* --- found the queue ? --- */
		if (pQueues->usQueNo == usQueNo) {		/* inspect the queue ID		*/
			/* --- clear queue control --- */
			pQueues->usQueNo = 0;					/* let it vacant		*/
			usRet            = 0;					/* completed status		*/

			/* --- discard its resources --- */
			QueDeleteResource(pQueues);				/* delete it			*/
			break;									/* break my job here	*/
		}

		/* --- how about next queue cell ? --- */
		pQueues++;								/* go to next queue			*/
	}

	/* --- free a semaphore --- */
//	SysSemClear(&semQueue);
	LeaveCriticalSection (&csQueueCriticalSection);

	return (usRet);
}

/**
;============================================================================
;+																			+
;+			Q U E U E    H A N D L I N G    P R I M I T I V E S				+
;+																			+
;============================================================================
**/

/**
;=======================================================================
;
;	function : initialize a queue
;
;   format : VOID		QueInitialize(pQueue);
;
;   input  : PQUEPTR	pQueue;				- queue pointer
;
;   output : nothing
;
;=======================================================================
**/

VOID	QueInitialize(PQUEPTR pQueue)
{
	/* --- initialize queue contents --- */
	pQueue->pFirst	 = _NULL;					/* no chains				*/
	pQueue->pLast	 = _NULL;					/* no chains				*/
	pQueue->usCount  = 0;						/* no buffer chains			*/
}

/**
;=======================================================================
;
;	function : Enque a buffer, adding a buffer to the end of a queue
;
;   format : VOID		QueListBuffer(pQueue, pBuffer);
;
;   input  : PQUEPTR	pQueue;			- queue pointer
;			 PQUEBUF	pBuffer;		- queue buffer pointer
;
;   output : nothing
;
;   description:  There are two types of queues that are used within the
;                 network layer. One type is used to send messages between
;                 threads within the network layer. The second type is to
;                 queue up messages in a FIFO queue for each user thread
;                 (Server Thread, Client Thread, Notice Board Thread, etc.)
;
;                 The first queue type is the queues used by the functions
;                 SysReadQueue() and SysWriteQueue() which are used by
;                 several threads within the network layer for sending messages
;                 between threads with specific duties such as receiving messages,
;                 sending messages, and the timer thread. These must be synchronized
;                 since they are accessed by several different threads.
;
;                 The second queue type is the queues used to hold messages for a particular
;                 user thread in a First In First Out manner when a message comes in for a
;                 user thread and the user thread does not have a pending network read. The
;                 message is put onto the user thread queue and then aged by the Timer thread
;                 in the network layer until it is either picked up by the user thread before
;                 the tick count expires or the tick count expires and the Timer thread
;                 in the network layer removes the message from the user thread queue. These
;                 queues are not synchronized since the only thread modifying them is the
;                 Network Manager thread in the netowrk layer.
;=======================================================================
**/

VOID	QueListBuffer(PQUEPTR pQueue, PQUEBUF pBuffer)
{
	/* --- queues buffer --- */
	if (pQueue->pFirst == _NULL ) {				/* is virgin queue ?		*/
		pQueue->pFirst = pBuffer;					/* link to top of list	*/
		pQueue->pLast  = pBuffer;					/* also, bottom list	*/
	} else {									/* else, some buffer queued	*/
		(pQueue->pLast)->pChain = pBuffer;			/* link to bottom list	*/
		pQueue->pLast           = pBuffer;			/* this is last node	*/
	}

	/* --- initialize the buffer's chain --- */
	pBuffer->pChain = _NULL;					/* init. buffer's chain		*/

	/* --- count up --- */
	(pQueue->usCount)++;						/* add by 1 buffer			*/
}

/**
;=======================================================================
;
;	function : Deque a buffer
;
;   format : PQUEBUF	QueGetBuffer(pQueue);
;
;   input  : PQUEPTR	pQueue;			- queue pointer
;
;   output : PQUEBUF	pBuffer;		- buffer pointer
;
;=======================================================================
**/

PQUEBUF	QueGetBuffer(PQUEPTR pQueue)
{
	PQUEBUF		pWork;

	/* --- deques buffer --- */
	if (pWork = pQueue->pFirst) {				/* is any buffer on queue ?	*/
		pQueue->pFirst = pWork->pChain;				/* set next buffer top	*/
		pWork->pChain  = _NULL;						/* init. chain field	*/
		(pQueue->usCount)--;						/* sub. by 1 buffer		*/
	}

	/* --- respond a buffer ptr. --- */
	return (pWork);
}

/**
;=======================================================================
;
;	function : Peek a buffer
;
;   format : PQUEBUF	QuePeekBuffer(pQueue);
;
;   input  : PQUEPTR	pQueue;			- queue pointer
;
;   output : PQUEBUF	pBuffer;		- buffer pointer
;
;=======================================================================
**/

PQUEBUF	QuePeekBuffer(PQUEPTR pQueue)
{
	/* --- respond a buffer ptr. --- */
	return (pQueue->pFirst);					/* respond 1st queue ptr.	*/
}

/**
;=======================================================================
;
;	function : Get queue counts
;
;   format : USHORT		QueEnumBuffer(pQueue);
;
;   input  : PQUEPTR	pQueue;			- queue pointer
;
;   output : USHORT		usCounts;		- no. of queued buffers
;
;=======================================================================
**/

USHORT	QueEnumBuffer(PQUEPTR pQueue)
{
	/* --- respond no. of buffers --- */
	return (pQueue->usCount);
}

/**
;============================================================================
;+																			+
;+				Q U E U E    S I G N A L    H A N D L I N G					+
;+																			+
;============================================================================
**/

/**
;=======================================================================
;
;	function : Initialize a queue resource
;
;   format : VOID		QueInitResource(pQueue);
;
;   input  : PQUELST	pQueue;				- queue pointer
;
;   output : nothing
;
;=======================================================================
**/

VOID	QueInitResource(PQUELST pQueue)
{
	/* --- create semaphore & event signal --- */
	SysSemCreate(&(pQueue->semAttach), FALSE);		/* not yet block it		*/
	SysEventCreate(&(pQueue->evtSignal), FALSE);	/* not yet block it		*/
}

/**
;=======================================================================
;
;	function : Discard a queue resource
;
;   format : VOID		QueDeleteResource(pQueue);
;
;   input  : PQUELST	pQueue;				- queue pointer
;
;   output : nothing
;
;=======================================================================
**/

VOID	QueDeleteResource(PQUELST pQueue)
{
	/* --- create semaphore & event signal --- */
	SysSemClose(&(pQueue->semAttach));				/* not yet block it		*/
	SysEventClose(&(pQueue->evtSignal));			/* not yet block it		*/
}

/**
;=======================================================================
;
;	function : attach a queue resource
;
;   format : VOID		QueAttachResource(pQueue);
;
;   input  : PQUELST	pQueue;				- queue pointer
;
;   output : nothing
;
;=======================================================================
**/

VOID	QueAttachResource(PQUELST pQueue)
{
	SysSemRequest(&(pQueue->semAttach), WAIT_FOREVER);
}

/**
;=======================================================================
;
;	function : free a queue resources
;
;   format : VOID		QueFreeResource(pQueue);
;
;   input  : PQUELST	pQueue;				- queue pointer
;
;   output : nothing
;
;=======================================================================
**/

VOID	QueFreeResource(PQUELST pQueue)
{
	SysSemClear(&(pQueue->semAttach));
}

/*==========================================================================*\
;+						E n d   O f   P r o g r a m							+
\*==========================================================================*/
