/*
****************************************************************************
**                                                                        **
**        *=*=*=*=*=*=*=*=*                                               **
**        *  NCR 2171     *             NCR Corporation, E&M OISO         **
**     @  *=*=*=*=*=*=*=*=*  0             (C) Copyright, 1999            **
**    <|\/~               ~\/|>                                           **
**   _/^\_                 _/^\_                                          **
**                                                                        **
****************************************************************************
*===========================================================================
* Title       : fstrxxx functions
* Category    : Reentrant Functions Library, NCR 2171 US hospitarity Application
* Program Name: rflfstr.c
* --------------------------------------------------------------------------
* Compiler    : cl for VC++ Ver 6.0 by Microsoft Corp.                         
* --------------------------------------------------------------------------
* Abstract:
*      * This file contains following funcions,
*       _RflFStrCat()
*       _RflFStrChr()
*
*      * On 16bit x86 platform (2170HPUS), fstrcat/fstrchr was used.
*      * At the migration work (to 2171HPUS), we desided to create these
*        functions as wrapper.
* --------------------------------------------------------------------------
* Update Histories                                                         
*  Date     : Ver.Rev. :   Name     : Description
* Sep-03-99 : 01.00.00 : M.Teraki   : initial (for Win32)
*===========================================================================
* PVCS Entry
* --------------------------------------------------------------------------
* $Revision$
* $Date$
* $Author$
* $Log$
*===========================================================================
*/

/**
;========================================================================
;+                                                                      +
;+                  I N C L U D E     F I L E s                         +
;+                                                                      +
;========================================================================
**/

// Define the following to indicate to the Windows included files
// that we are compiling this for Windows NT 4.0 and later.
// This includes Windows XP.  We need this in order to access the
// Windows crypto library functions.

#define _WIN32_WINNT  0x0400
#define WINVER        0x0400

#include <windows.h>
#include <wincrypt.h>

#include <stdio.h>

#if !defined(MS_STRONG_PROV)
// Code copied from latest Windows SDK header files to allow us
// to use the MS_STRONG_PROV Cryptographic Services Provider.
#define MS_STRONG_PROV_A        "Microsoft Strong Cryptographic Provider"
#define MS_STRONG_PROV_W        L"Microsoft Strong Cryptographic Provider"
#ifdef UNICODE
#define MS_STRONG_PROV          MS_STRONG_PROV_W
#else
#define MS_STRONG_PROV          MS_STRONG_PROV_A
#endif

#endif

/************************************************************************

Cryptographic Provider Names
The following cryptographic service provider (CSP) names
are defined: These constants are used with the
CryptAcquireContext and CryptSetProvider functions.

Defined name					Value 
MS_DEF_PROV					"Microsoft Base Cryptographic Provider v1.0" 
MS_ENHANCED_PROV			"Microsoft Enhanced Cryptographic Provider " 
MS_STRONG_PROV				"Microsoft Strong Cryptographic Provider" 
MS_DEF_RSA_SIG_PROV			"Microsoft RSA Signature Cryptographic Provider" 
MS_DEF_RSA_SCHANNEL_PROV	"Microsoft RSA SChannel Cryptographic Provider" 
MS_DEF_DSS_PROV				"Microsoft Base DSS Cryptographic Provider" 
MS_DEF_DSS_DH_PROV			"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider" 
MS_ENH_DSS_DH_PROV			"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider" 
MS_DEF_DH_SCHANNEL_PROV		"Microsoft DH SChannel Cryptographic Provider" 
MS_SCARD_PROV				"Microsoft Base Smart Card Cryptographic Provider" 


Hash algorithm names
The following constants are used with the 
CryptCreateHash function.

Defined name			Value				Specified by Provider Types
CALG_MD5			MD5 algorithm		PRON_RSA_FULL, PROV_RSA_SIG, PROV_DSS, PROV_DSS_DH, and PROV_MS_EXCHANGE
CALG_SHA			SHA-1 algorithm
CALG_3DES			Triple DES algorithm


GetLastError () return values CryptAcquireContext(), CryptEncrypt().

The error codes prefaced by NTE are generated by the particular CSP being used.
Some possible error codes follow. 

ERROR_NOT_ENOUGH_MEMORY ( 8L ) 
  The operating system ran out of memory during the operation. 

ERROR_INVALID_PARAMETER ( 87L ) 
  One of the parameters contains an invalid value. This is most often an invalid pointer. 

ERROR_BUSY ( 107L ) 
  Some CSPs set this error if the CRYPT_DELETEKEYSET flag value is set and another
  thread or process is using this key container. 

ERROR_MORE_DATA (234L)
  The buffer specified is not large enough to hold the data (function CryptEncrypt).

NTE_BAD_SIGNATURE( 0x80090006L ) 
  The provider DLL signature could not be verified. Either the DLL or the digital
  signature has been tampered with. 

NTE_BAD_ALGID (0x80090008L)
  The Algid parameter specifies an algorithm that this CSP does not support.

NTE_BAD_FLAGS ( 0x80090009L ) 
  The dwFlags parameter has an invalid value.

NTE_NO_MEMORY( 0x8009000EL ) 
  The CSP ran out of memory during the operation. 

NTE_EXISTS( 0x8009000FL ) 
  The dwFlags parameter is CRYPT_NEWKEYSET, but the key container already exists. 

NTE_BAD_PROV_TYPE( 0x80090014L ) 
  The value of the dwProvType parameter is out of range. All provider types must be from 1 to 999, inclusive. 

NTE_BAD_KEYSET( 0x80090016L ) 
  The key container could not be opened. A common cause of this error is that the key container
  does not exist. To create a key container, call CryptAcquireContext using the CRYPT_NEWKEYSET flag.
  This error code can also indicate that access to an existing key container is denied. Access rights
  to the container can be granted by the key set creator using CryptSetProvParam. 

NTE_BAD_KEYSET_PARAM( 0x8009001FL ) 
  The pszContainer or pszProvider parameter is set to an invalid value. 

NTE_PROV_DLL_NOT_FOUND( 0x80090016L ) 
  The provider DLL file does not exist or is not on the current path. 

NTE_PROV_TYPE_NOT_DEF( 0x80090017L ) 
  No entry exists for the provider type specified by dwProvType. 

NTE_PROV_TYPE_ENTRY_BAD( 0x80090018L ) 
  The provider type specified by dwProvType is corrupt. This error can relate to either the
  user default CSP list or the computer default CSP list. 

NTE_KEYSET_NOT_DEF( 0x80090019L ) 
  The key container specified by pszContainer does not exist or the requested provider does not exist. 

NTE_KEYSET_ENTRY_BAD( 0x8009001AL ) 
  The pszContainer key container was found but is corrupt. 

NTE_PROV_TYPE_NO_MATCH( 0x8009001BL ) 
  The provider type specified by dwProvType does not match the provider type found. Note that this error
  can only occur when pszProvider specifies an actual CSP name. 

NTE_SIGNATURE_FILE_BAD( 0x8009001CL ) 
  An error occurred while loading the DLL file image, prior to verifying its signature. 

NTE_PROVIDER_DLL_FAIL( 0x8009001DL ) 
  The provider DLL file could not be loaded or failed to initialize. 

**************************************************************************/

#define MY_ENCODING_TYPE      (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)
  // indicate 128 bit session key
#define KEYLENGTH             0x00800000


#include <tchar.h>
#include <string.h>

#include "ecr.h"
#include "rfl.h"
#include "pif.h"


//--------------------------------------------------------------------
//   Declare and initialize local variables.

static HCRYPTPROV hCryptProv = 0; 
static HCRYPTKEY  hKey = 0; 
static HCRYPTKEY  hXchgKey = 0; 
static HCRYPTHASH hHash = 0; 

static PBYTE      pbKeyBlob = 0; 
static DWORD      dwKeyBlobLen = 0;

static UCHAR      ucPasswordSaveAndCheck[6];

int  RflConstructEncryptByteStringClass (CONST CHAR *szPassword)
{
	// Get handle to the default provider. 
	if(! CryptAcquireContext(&hCryptProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
		DWORD  dwLastError = GetLastError();
		if (dwLastError == NTE_EXISTS) {
			if(! CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)) {
				NHPOS_ASSERT_TEXT(0, "Error during CryptAcquireContext!");
				return -1;
			}
		}
		else {
			NHPOS_ASSERT_TEXT(0, "Error during CryptAcquireContext CRYPT_NEWKEYSET!");
			return -1;
		}
	}

	//--------------------------------------------------------------------
	//   Create the session key.
	if(szPassword || szPassword [0] != 0) { 
		RflRehashEncryptDecrypt (szPassword);
	} 
	//--------------------------------------------------------------------
	//  The session key is now ready. If it is not a key derived from a 
	//  password, the session key encrypted with the encrypter's private 
	//  key has been written to the destination file.

	return 1;
}


VOID RflDestructEncryptByteStringClass (VOID)
{
	//--------------------------------------------------------------------
	// Destroy session key. 
	if(hKey) 
		CryptDestroyKey(hKey); 

	//--------------------------------------------------------------------
	// Release key exchange key handle. 
	if(hXchgKey) 
		CryptDestroyKey(hXchgKey); 
 
	//--------------------------------------------------------------------
	// Destroy hash object. 
	if(hHash) 
		CryptDestroyHash(hHash); 
 
	//--------------------------------------------------------------------
	// Release provider handle. 
	if(hCryptProv) 
		CryptReleaseContext(hCryptProv, 0);

	hKey = hXchgKey = hHash = hCryptProv = 0;
}


#if defined(RflRehashEncryptDecrypt)
int RflRehashEncryptDecrypt_Special (CHAR *szPassword);

int RflRehashEncryptDecrypt_Debug (CONST CHAR *szPassword, char *aszFilePath, int nLineNo)
{
	char  xBuffer[256];

	sprintf (xBuffer, "RflRehashEncryptDecrypt_Debug(): File %s, lineno = %d", aszFilePath, nLineNo);
	NHPOS_ASSERT_TEXT(0, xBuffer);
	return RflRehashEncryptDecrypt_Special (szPassword);
}
int RflRehashEncryptDecrypt_Special (CHAR *szPassword)
#else
int  RflRehashEncryptDecrypt (CONST CHAR *szPassword)
#endif
{
	//--------------------------------------------------------------------
	// Destroy session key as we are going to create a new one.
	if(hKey) {
		CryptDestroyKey(hKey);
		hKey = 0;
	}

	//--------------------------------------------------------------------
	// Destroy hash object as we are going to create a new one.
	if(hHash) {
		CryptDestroyHash(hHash);
		hHash = 0;
	}

	NHPOS_ASSERT_TEXT((hCryptProv != 0), "RflRehashEncryptDecrypt(): hCryptProv object not available.");

	// Create a hash object. We are using CALG_MD5 (MD5) for our hashing algorithm.
	if(! CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash)) {
		DWORD  dwLastError = GetLastError();
		NHPOS_ASSERT_TEXT(0, "Error during CryptCreateHash!\n");
		RflDestructEncryptByteStringClass();
		return -1;
	}

	//--------------------------------------------------------------------
	// Hash the password. 
	if(! CryptHashData(hHash, (BYTE *)szPassword, strlen(szPassword), 0)) {
		DWORD  dwLastError = GetLastError();
		NHPOS_ASSERT_TEXT(0, "Error during CryptHashData. \n"); 
		RflDestructEncryptByteStringClass();
		return -1;
	}

	//--------------------------------------------------------------------
	// Derive a session key from the hash object. 
	if(! CryptDeriveKey(hCryptProv, CALG_3DES, hHash, (0), &hKey)) {
		DWORD  dwLastError = GetLastError();
		NHPOS_ASSERT_TEXT(0, "Error during CryptDeriveKey CALG_3DES\n");

		if(! CryptDeriveKey(hCryptProv, CALG_DES, hHash, (0), &hKey)) {
			DWORD  dwLastError = GetLastError();
			NHPOS_ASSERT_TEXT(0, "Error during CryptDeriveKey CALG_DES\n");

			if(! CryptDeriveKey(hCryptProv, CALG_RC4, hHash, (0), &hKey)) {
				DWORD  dwLastError = GetLastError();
				NHPOS_ASSERT_TEXT(0, "Error during CryptDeriveKey CALG_RC4\n"); 
				RflDestructEncryptByteStringClass();
				return -1;
			}
		}
	}

	//--------------------------------------------------------------------
	// Destroy the no longer needed hash object. 
	CryptDestroyHash(hHash); 
	hHash = 0;

	memcpy (ucPasswordSaveAndCheck, szPassword, sizeof(ucPasswordSaveAndCheck));
	return 0;
} 


#if defined(RflEncryptByteString)
UCHAR * RflEncryptByteString_Special (UCHAR *bsString, int nByteCount);

UCHAR * RflEncryptByteString_Debug (UCHAR *bsString, int nByteCount, char *aszFilePath, int nLineNo)
{
	char  xBuffer[256];

	sprintf (xBuffer, "RflEncryptByteString_Debug(): File %s, lineno = %d", aszFilePath, nLineNo);
	NHPOS_ASSERT_TEXT(0, xBuffer);
	return RflEncryptByteString_Special (bsString, nByteCount);
}
UCHAR * RflEncryptByteString_Special (UCHAR *bsString, int nByteCount)
#else
UCHAR * RflEncryptByteString (UCHAR *bsString, int nByteCount)
#endif
{
	DWORD  dwCount = nByteCount - 5;

	// ensure that we have an encryption key and that the string is not empty
	if (hKey && bsString && (bsString[0] | bsString[1]) != 0) {
		// Encrypt data. 
		if(!CryptEncrypt(hKey, 0, TRUE, 0, bsString, &dwCount, nByteCount))
		{
			char  xBuff[128];
			DWORD  dwLastError = GetLastError();

			sprintf (xBuff, "RflEncryptByteString(): ERROR %d, dwCount=%d, nByteCount=%d", dwLastError, dwCount, nByteCount);
			NHPOS_ASSERT_TEXT(0, xBuff); 
			bsString[nByteCount - 1] = 0;
			bsString = NULL;
		}
		else {
			bsString[nByteCount - 1] = (UCHAR) dwCount;
		}
	}
	else {
		bsString[nByteCount - 1] = 0;
		bsString = NULL;
	}
	return bsString;
}


#if defined(RflDecryptByteString)
UCHAR * RflDecryptByteString_Special (UCHAR *bsString, int nByteCount);

UCHAR * RflDecryptByteString_Debug (UCHAR *bsString, int nByteCount, char *aszFilePath, int nLineNo)
{
	char  xBuffer[256];

	sprintf (xBuffer, "RflDecryptByteString_Debug(): File %s, lineno = %d", aszFilePath, nLineNo);
	NHPOS_ASSERT_TEXT(0, xBuffer);
	return RflDecryptByteString_Special (bsString, nByteCount);
}
UCHAR * RflDecryptByteString_Special (UCHAR *bsString, int nByteCount)
#else
UCHAR * RflDecryptByteString (UCHAR *bsString, int nByteCount)
#endif
{
	DWORD  dwCount = bsString[nByteCount - 1];
	DWORD  dwByteCount = (DWORD) nByteCount;

	// Lets make sure that we do not try to decrypt an already decrypted string
	bsString[nByteCount - 1] = 0;
	if (hKey && bsString && (bsString[0] | bsString[1]) != 0 && dwCount && dwCount < dwByteCount) {
		if(!CryptDecrypt(hKey, 0,TRUE, 0, bsString, &dwCount))
		{
			char  xBuff[128];
			DWORD  dwLastError = GetLastError();

			sprintf (xBuff, "RflDecryptByteString(): ERROR %d, dwCount=%d, nByteCount=%d", dwLastError, dwCount, nByteCount);
			NHPOS_ASSERT_TEXT(0, xBuff); 
			bsString = NULL;
		}
		else {
			nByteCount = dwCount;
		}
	}
	else {
		bsString = NULL;
	}

	return bsString;
}

// create a print line in the buffer aszPrintLine which contains two instances
// of the mnemonic aszMnem.
USHORT RflFormatLineTwoColumn (TCHAR *aszPrintLine, TCHAR *aszMnemLeft, TCHAR *aszMnemRight, int iLineLen)
{
	int iOffset = iLineLen / 2;
	int  iLoop, iMnemLenLeft = 0, iMnemLenRight = 0;

	if (aszMnemLeft)
		iMnemLenLeft = _tcslen(aszMnemLeft);
	if (aszMnemRight)
		iMnemLenRight = _tcslen(aszMnemRight);
	if (iMnemLenLeft > iOffset) iMnemLenLeft = iOffset;
	if (iMnemLenRight > iOffset) iMnemLenRight = iOffset;
	for (iLoop = 0; iLoop < iOffset; iLoop++) {
		if (aszMnemLeft && iLoop < iMnemLenLeft) {
			aszPrintLine[iLoop] = aszMnemLeft[iLoop];
		} else {
			aszPrintLine[iLoop] = _T(' ');
		}
		if (aszMnemRight &&  iLoop < iMnemLenRight) {
			aszPrintLine[iLoop + iOffset] = aszMnemRight[iLoop];
		} else {
			aszPrintLine[iLoop + iOffset] = _T(' ');
		}
	}
	aszPrintLine[iLoop + iOffset] = 0;

	return (USHORT)(iLoop + iOffset);
}

/*==========================================================================
**  Synopsis:   int    RflConvertSubStringToInt (CONST UCHAR *auchString, int iLen)
*
*   Input:      UCHAR  *auchString - pointer to first of one or more characters to convert
*               int    iLen - max number of characters to use in the number to convert
*   Output:     none
*   InOut:      none
*
*   Return:     integer value of the digits designated
*
*   Description:   Convert one or more text digits into an integer value.
*                  This function is designed to be used to convert a sub-string
*                  of a text string that is not zero terminated with an end of
*                  string character and contains integer digits into an integer
*                  value. However if the digits are in a zero terminated that
*                  is shorter than the max number of digits then only that part
*                  of the sub-string will be processed.
*
*                  There are a number of places in the Electronic Payment Interface
*                  code where a large text string is composed of multiple sub-strings
*                  of digits for specific data items and these sub-strings are not
*                  zero terminated but rather occupy several positions within the
*                  entire array of characters. This function is used to isolate a
*                  sub-string by specifying a starting place and length and to
*                  then convert the digits into a single integer value.
*
*                  WARNING: There is no check on the content of the sub-string
*                  so the parsing and conversion rules of the atoi() function apply.
*                  Leading dash will be interpreted as a negative sign. Processing
*                  of digits will stop at first non-digit.
==========================================================================*/
int  RflConvertSubStringToInt (CONST UCHAR *auchString, int iLen)
{
	CHAR  tcsBuff[32] = {0};
	CHAR  *p = tcsBuff;

	if (iLen > 30) iLen = 30;

	while ( (iLen-- > 0) && (*p++ = *auchString++) );

	return atoi(tcsBuff);
}

/**
;============================================================================
; end of file
;============================================================================
**/
